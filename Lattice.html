<!DOCTYPE HTML>
<html>
  <head>
    <style>
        body {
        margin: 0px;
        padding: 0px;
      }
    </style>
  </head>
  <body> 
      
    <div id="container"></div>
    <script src="src/jquery-2.0.3.min.js"></script>
    <script src="src/jquery-ui.min.js"></script>
    <script src="src/three.min.js"></script>
    <script src="src/OrbitControls.js"></script>
    <script src="src/dat.gui.min.js"></script>
    <script>
        
    THREE.EdgesHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	var edge = [ 0, 0 ], hash = {};
	var sortFunction = function ( a, b ) { return a - b };

	var keys = [ 'a', 'b', 'c' ];
	var geometry = new THREE.BufferGeometry();

	var geometry2 = object.geometry.clone();

	geometry2.mergeVertices();
	geometry2.computeFaceNormals();

	var vertices = geometry2.vertices;
	var faces = geometry2.faces;
	var numEdges = 0;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0; j < 3; j ++ ) {

			edge[ 0 ] = face[ keys[ j ] ];
			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
			edge.sort( sortFunction );

			var key = edge.toString();

			if ( hash[ key ] === undefined ) {

				hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };
				numEdges ++;

			} else {

				hash[ key ].face2 = i;

			}

		}

	}

	geometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );

	var coords = geometry.attributes.position.array;

	var index = 0;

	for ( var key in hash ) {

		var h = hash[ key ];

		if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) < 0.9999 ) { // hardwired const OK

			var vertex = vertices[ h.vert1 ];
			coords[ index ++ ] = vertex.x;
			coords[ index ++ ] = vertex.y;
			coords[ index ++ ] = vertex.z;

			vertex = vertices[ h.vert2 ];
			coords[ index ++ ] = vertex.x;
			coords[ index ++ ] = vertex.y;
			coords[ index ++ ] = vertex.z;

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;
	this.matrixWorld = object.matrixWorld;

};

THREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );

        
var gui, parameters;
var renderer, scene, camera, controls;
var active_planes;
var egh;

init();
animate();

function init() {

	// info
	info = document.createElement( 'div' );
	info.style.position = 'absolute';
	info.style.top = '30px';
	info.style.width = '100%';
	info.style.textAlign = 'center';
	info.style.color = '#fff';
	info.style.fontWeight = 'bold';
	info.style.backgroundColor = 'transparent';
	info.style.zIndex = '1';
	info.style.fontFamily = 'Monospace';
	info.innerHTML = 'Lattice Demo';
	document.body.appendChild( info );

	// renderer
	renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.physicallyBasedShading = true;
	document.body.appendChild( renderer.domElement );

	// scene
	scene = new THREE.Scene();
	
	// camera
	camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.1, 100 );
	camera.position.set( -4, 2, 8 );

	// controls
	controls = new THREE.OrbitControls( camera );
	controls.minDistance = 5;
	controls.maxDistance = 20;
	

	// ambient
	scene.add( new THREE.AmbientLight( 0x222222 ) );
	
	// light
	var light = new THREE.PointLight( 0x222222, 0.8 );
	light.position = camera.position;
	scene.add( light );

	// Unit Cell
	var Lattice = new THREE.CylinderGeometry( 1, 1, 2, 6, 1, false );
	Lattice.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0, 0 ) );
	var LatticeMaterial = new THREE.MeshBasicMaterial( {
		color: 0x000000,
		shading: THREE.FlatShading,
		polygonOffset: true,
		polygonOffsetFactor: 1,
		polygonOffsetUnits: 1,
		transparent: true,
		opacity: .5
	} );
	// mesh
	var LatticeMesh = new THREE.Mesh( Lattice, LatticeMaterial );
	scene.add( LatticeMesh );

	// helper
	egh = new THREE.EdgesHelper( LatticeMesh, 0xFFFFFF );
	egh.material.transparent = true;
	egh.material.linewidth = 5;
	scene.add( egh );
	
	var vertices = Lattice.vertices;											       

	//c plane
	var cPlaneColor = new THREE.Color( 0xFF0000 );       
    	var cPlane = new THREE.Geometry();
	cPlane.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0, 0 ) );

	cPlane.vertices.push( vertices[0] );
        cPlane.vertices.push( vertices[1] );
        cPlane.vertices.push( vertices[2] );
        cPlane.vertices.push( vertices[3] );
        cPlane.vertices.push( vertices[4] );
        cPlane.vertices.push( vertices[5] );
        cPlane.faces.push( new THREE.Face3( 0, 1, 2 ) );
        cPlane.faces.push( new THREE.Face3( 0, 2, 3) );
        cPlane.faces.push( new THREE.Face3( 0, 3, 4) );
        cPlane.faces.push( new THREE.Face3( 0, 4, 5) );
        cPlane.computeBoundingSphere();

        //a plane
	var aPlaneColor = new THREE.Color( 0x0000FF );       
        var aPlane = new THREE.Geometry();
	aPlane.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0, 0 ) );

	aPlane.vertices.push( vertices[2] );
        aPlane.vertices.push( vertices[0] );
        aPlane.vertices.push( vertices[7] );
        aPlane.vertices.push( vertices[9] );
        aPlane.faces.push( new THREE.Face3( 0, 1, 2 ) );
        aPlane.faces.push( new THREE.Face3( 2, 3, 0 ) );
        aPlane.computeBoundingSphere();
        
        //m plane
	var mPlaneColor = new THREE.Color( 0x00FF00 );       
        var mPlane = new THREE.Geometry();
	mPlane.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0, 0 ) );

	mPlane.vertices.push( vertices[1] );
        mPlane.vertices.push( vertices[0] );
        mPlane.vertices.push( vertices[7] );
        mPlane.vertices.push( vertices[8] );
        mPlane.faces.push( new THREE.Face3( 0, 1, 2 ) );
        mPlane.faces.push( new THREE.Face3( 2, 3, 0 ) );
        mPlane.computeBoundingSphere();
    

    
    var cMaterial = new THREE.MeshBasicMaterial( {
		color: cPlaneColor,
		shading: THREE.FlatShading
	} );

    var aMaterial = new THREE.MeshBasicMaterial( {
		color: aPlaneColor,
		shading: THREE.FlatShading,
	} );
	
    var mMaterial = new THREE.MeshBasicMaterial( {
		color: mPlaneColor,
		shading: THREE.FlatShading,
	} );


    active_planes = [false, false, false, false];
    
	

	
    var cPlaneMesh = new THREE.Mesh(cPlane, cMaterial );
    scene.add( cPlaneMesh );

    var aPlaneMesh = new THREE.Mesh(aPlane, aMaterial );
    scene.add( aPlaneMesh );
    
    var mPlaneMesh = new THREE.Mesh(mPlane, mMaterial );
    scene.add( mPlaneMesh );

    //setup GUI
    gui = new dat.GUI();
    parameters = 
	{
	cPlaneVisible: false,
        aPlaneVisible: false,
        mPlaneVisible: false,
        rPlaneVisible: false,
        axisVisible: false,
		reset: function() { resetLattice() }
	};
    var cPlaneVisible = gui.add( parameters, 'cPlaneVisible' ).name('C Plane').listen();
	cPlaneVisible.onChange(function(value) 
	{   //c Plane
        cPlane.visible = value;
        
    });
     var aPlaneVisible = gui.add( parameters, 'aPlaneVisible' ).name('A Plane').listen();
	aPlaneVisible.onChange(function(value) 
	{   //c Plane
    
    });
     var mPlaneVisible = gui.add( parameters, 'mPlaneVisible' ).name('M Plane').listen();
	mPlaneVisible.onChange(function(value) 
	{   //c Plane
    
    });
    var rPlaneVisible = gui.add( parameters, 'rPlaneVisible' ).name('R Plane').listen();
	rPlaneVisible.onChange(function(value) 
	{   //c Plane
    
    });
    var axisVisible = gui.add( parameters, 'axisVisible' ).name('Axis').listen();
	rPlaneVisible.onChange(function(value) 
	{   //c Plane
    
    });
    gui.add( parameters, 'reset' ).name("Reset Cube Parameters");
    gui.open();
}

function animate() {

	requestAnimationFrame( animate );  
	renderer.render( scene, camera );
    update();
}
 
function resetLattice()
{
    
}      

function update()
{
    /*
	if ( keyboard.pressed("a") ) {
    
    }
	if ( keyboard.pressed("m") ) {
    
    }
	if ( keyboard.pressed("r") ) {
    
    }
	*/
    
	controls.update();
	//stats.update();
}
</script>
  </body>
</html>
