<html>
  <head>
    <style>
        body {
        margin: 0px;
        padding: 0px;
      }
    </style>
  </head>
  <body> 
      
    <div id="container"></div>
    <script src="src/jquery-2.0.3.min.js"></script>
    <script src="src/jquery-ui.min.js"></script>
    <script src="src/three.min.js"></script>
    <script src="src/EdgesHelper.js"></script>
    <script src="src/OrbitControls.js"></script>
    <script src="src/BufferGeometry.js"></script>
    <script src="src/math/Matrix4.js"></script>
    <script src="src/KeyboardState.js"></script>
    <script src="src/BufferGeometryUtils.js"></script>
    <script>

        
var gui, parameters;
var renderer, scene, camera, controls;
var mesh;
var egh;
       
var clock = new THREE.Clock();
var keyboard = new KeyboardState();
        
init();
animate();     
        
function init() {

	// info
	info = document.createElement( 'div' );
	info.style.position = 'absolute';
	info.style.top = '30px';
	info.style.width = '100%';
	info.style.textAlign = 'center';
	info.style.color = '#fff';
	info.style.fontWeight = 'bold';
	info.style.backgroundColor = 'transparent';
	info.style.zIndex = '1';
	info.style.fontFamily = 'Monospace';
	info.innerHTML = 'Lattice Demo';
	document.body.appendChild( info );

	// renderer
	renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );

	// scene
	scene = new THREE.Scene();
	
	// camera
	camera = new THREE.PerspectiveCamera(10, window.innerWidth / window.innerHeight, 1, 1000   );
    camera.position.set(0, 1000, 0);
    camera.zoom = .3;
    scene.add(camera);
    
	// controls
	controls = new THREE.OrbitControls( camera );
    //controls.addEventListener( 'change', render );
    
    
	// ambient
	scene.add( new THREE.AmbientLight( 0x222222 ) );
	
	// light
	var light = new THREE.PointLight( 0x222222, 0.8 );
	light.position = camera.position;
	scene.add( light );
     
    var positions = new Array();
    var colors = new Array();
    var indices = new Array();

    var material = new THREE.LineBasicMaterial({ vertexColors: true , linewidth:2});
    
    function draw_hex_lattice(size, lattice_rotation, mesh_rotation, start, end, color, obj) {
        var Lattice = new THREE.CylinderGeometry( 1*size, 1*size, 2*size, 6, 1, false );
        Lattice.applyMatrix(lattice_rotation);
        var geometry = new THREE.BufferGeometry();
        positions[obj] = new Array();
        colors[obj] = new Array();
        indices[obj] = new Array();
        
        
        function add_vertex(x, y, z) {
				positions[obj].push(x, y, z);
				colors[obj].push(color.x, color.y, color.z);
        }
        
        var idx = 0;
        function make_lattice(p, o) {
            
            for(var i = 0; i < Lattice.vertices.length; ++i) {
                add_vertex(Lattice.vertices[i].x+p.x, Lattice.vertices[i].y+p.y, Lattice.vertices[i].z+p.z, color);
            }
            
            indices[obj].push(idx, idx+1);
            indices[obj].push(idx+1, idx+2);
            indices[obj].push(idx+2, idx+3);
            indices[obj].push(idx+3, idx+4);
            indices[obj].push(idx+4, idx+5);
            indices[obj].push(idx+5, idx);
            //indices_array.push(idx+6, idx+7);
            indices[obj].push(idx+7, idx+8);
            indices[obj].push(idx+8, idx+9);
            indices[obj].push(idx+9, idx+10);
            indices[obj].push(idx+10, idx+11);
            indices[obj].push(idx+11, idx+12);
            indices[obj].push(idx+12, idx+7);
            
            indices[obj].push(idx, idx+7);
            indices[obj].push(idx+1, idx+8);
            indices[obj].push(idx+2, idx+9);
            indices[obj].push(idx+3, idx+10);
            indices[obj].push(idx+4, idx+11);
            indices[obj].push(idx+5, idx+12);
            idx=idx+Lattice.vertices.length;
        }
        
        var r = Lattice.radiusTop;
        var a = r*Math.cos(Math.PI/6);
        var b = r*Math.sin(Math.PI/6);
        var h = Lattice.height;
        
        console.log(a);
        console.log(b);
        console.log(h);
        console.log(r);
        
        for(var y = start.y; y < end.y; y=y+1) {
            for(var x = start.x, s=0; x < end.x; x=x+5) {
                for(var z = start.z; z < end.z; z=z+1) {
                    make_lattice(new THREE.Vector3(x, y, z + s%2*a), obj);
                }
                ++s;
            }
        }
        
        geometry.addAttribute( 'position', Float32Array, positions[obj].length, 3 );
        geometry.attributes.position.array = new Float32Array(positions[obj]);
        geometry.addAttribute( 'color', Float32Array, colors[obj].length, 3 );
        geometry.attributes.color.array = new Float32Array(colors[obj]);
        geometry.addAttribute( 'index', Uint16Array, indices[obj].length, 1 );
        geometry.attributes.index.array = new Uint16Array(indices[obj]);
        geometry.offsets = [ {start:0, index:0, count:indices[obj].length} ];
        geometry.computeBoundingSphere();
        mesh = new THREE.Line( geometry, material, THREE.LinePieces);
        mesh.rotation.x = mesh_rotation.x;
        mesh.rotation.y = mesh_rotation.y;
        mesh.rotation.z = mesh_rotation.z;
        scene.add(mesh);
    }
        
    draw_hex_lattice(2, new THREE.Matrix4().makeRotationY(2*Math.PI/6), new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(20, 20, 20), new THREE.Vector3(.25, .25, 1), 0);
    draw_hex_lattice(1, new THREE.Matrix4().makeRotationY(Math.PI/6), new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(20, 20, 20), new THREE.Vector3(1, .25, .25), 0);
    controls.update();
}

        
function render() {
    renderer.render( scene, camera );
}
  
function animate() {

	requestAnimationFrame( animate );  
	renderer.render( scene, camera );
    update();
}
        
function rotateCamera(x, y) {
    camera.rotation.x+=y/360;
    camera.rotation.y+=x/360;
}
        
function update()
{
    keyboard.update();
    
	if( keyboard.pressed("W") ) rotateCamera(0,1);
    if( keyboard.pressed("S") ) rotateCamera(0,-1);
    if( keyboard.pressed("A") ) rotateCamera(1,0);
    if( keyboard.pressed("D") ) rotateCamera(-1,0);
    
    if( keyboard.pressed("shift") ) camera.lookAt(new THREE.Vector3(0,0,0));
	
	//stats.update();
}
        
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize( window.innerWidth, window.innerHeight );
    controls.handleResize();
    render();
}
</script>
  </body>
</html>
