<!DOCTYPE HTML>
<html>
  <head>
    <style>
        body {
        margin: 0px;
        padding: 0px;
      }
    </style>
  </head>
  <body> 
    <div id="container"></div>
    <script src="src/three.min.js"></script>
    <script>
        
        THREE.EdgesHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	var edge = [ 0, 0 ], hash = {};
	var sortFunction = function ( a, b ) { return a - b };

	var keys = [ 'a', 'b', 'c' ];
	var geometry = new THREE.BufferGeometry();

	var geometry2 = object.geometry.clone();

	geometry2.mergeVertices();
	geometry2.computeFaceNormals();

	var vertices = geometry2.vertices;
	var faces = geometry2.faces;
	var numEdges = 0;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0; j < 3; j ++ ) {

			edge[ 0 ] = face[ keys[ j ] ];
			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
			edge.sort( sortFunction );

			var key = edge.toString();

			if ( hash[ key ] === undefined ) {

				hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };
				numEdges ++;

			} else {

				hash[ key ].face2 = i;

			}

		}

	}

	geometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );

	var coords = geometry.attributes.position.array;

	var index = 0;

	for ( var key in hash ) {

		var h = hash[ key ];

		if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) < 0.9999 ) { // hardwired const OK

			var vertex = vertices[ h.vert1 ];
			coords[ index ++ ] = vertex.x;
			coords[ index ++ ] = vertex.y;
			coords[ index ++ ] = vertex.z;

			vertex = vertices[ h.vert2 ];
			coords[ index ++ ] = vertex.x;
			coords[ index ++ ] = vertex.y;
			coords[ index ++ ] = vertex.z;

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;
	this.matrixWorld = object.matrixWorld;

};

THREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );

var mesh, renderer, scene, camera, controls;
var active_planes;
var egh;

init();
animate();

function init() {

	// info
	info = document.createElement( 'div' );
	info.style.position = 'absolute';
	info.style.top = '30px';
	info.style.width = '100%';
	info.style.textAlign = 'center';
	info.style.color = '#fff';
	info.style.fontWeight = 'bold';
	info.style.backgroundColor = 'transparent';
	info.style.zIndex = '1';
	info.style.fontFamily = 'Monospace';
	info.innerHTML = 'Lattice Demo';
	document.body.appendChild( info );

	// renderer
	renderer = new THREE.WebGLRenderer( { antialias: true } ); // antialias = true makes wireframe look better
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.physicallyBasedShading = true;
	document.body.appendChild( renderer.domElement );

	// scene
	scene = new THREE.Scene();
	
	// camera
	camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.1, 100 );
	camera.position.set( -4, 2, 8 );

	// controls
	controls = new THREE.OrbitControls( camera );
	controls.minDistance = 5;
	controls.maxDistance = 20;
	
	// axes
	//scene.add( new THREE.AxisHelper( 20 ) );

	// ambient
	scene.add( new THREE.AmbientLight( 0x222222 ) );
	
	// light
	var light = new THREE.PointLight( 0x222222, 0.8 );
	light.position = camera.position;
	scene.add( light );

	// geometries
	var geometries = [];

	/*
    // 3D text geometry
	var text = "three.js*";
	var geometry = new THREE.TextGeometry( text, {

		size: 2,
		height: .2,

		font: "helvetiker",
		weight: "bold",
		style: "normal",

		bevelEnabled: false,
		bevelThickness: .05,
		bevelSize: .05,

	} );
	geometry.applyMatrix( new THREE.Matrix4().makeTranslation( -5, -2, 0 ) );
	geometries.push( geometry );
    */
	/*
	var text = "three.js*";
	var shapes = THREE.FontUtils.generateShapes( text, { size: 2, font: "helvetiker", weight: "bold", style: "normal" } );
	var geometry = new THREE.ShapeGeometry( shapes );
	geometry.applyMatrix( new THREE.Matrix4().makeTranslation( -5, 1, 0 ) );
	geometries.push( geometry );
    */
	// Lattice
	var Lattice = new THREE.CylinderGeometry( 1, 1, 2, 6, 4, false );
	Lattice.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0, 0 ) );
	geometries.push( Lattice );
	var vertices = Lattice.vertices;											       

	//c plane
	var cPlaneColor = new THREE.Color( 0xFF0000 );       
        var cPlane = new THREE.Geometry();
	cPlane.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0, 0 ) );

	cPlane.vertices.push( vertices[0] );
        cPlane.vertices.push( vertices[1] );
        cPlane.vertices.push( vertices[2] );
        cPlane.vertices.push( vertices[3] );
        cPlane.vertices.push( vertices[4] );
        cPlane.vertices.push( vertices[5] );
        cPlane.colors.push( cPlaneColor );
        cPlane.colors.push( cPlaneColor );
        cPlane.colors.push( cPlaneColor );
        cPlane.colors.push( cPlaneColor );
        cPlane.colors.push( cPlaneColor );
        cPlane.colors.push( cPlaneColor );
        cPlane.faces.push( new THREE.Face3( 0, 1, 2 ) );
        cPlane.faces.push( new THREE.Face3( 0, 2, 3) );
        cPlane.faces.push( new THREE.Face3( 0, 3, 4) );
        cPlane.faces.push( new THREE.Face3( 0, 4, 5) );
        cPlane.computeBoundingSphere();

        //c plane
	var aPlaneColor = new THREE.Color( 0x00FF00 );       
        var aPlane = new THREE.Geometry();
	cPlane.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0, 0 ) );

	aPlane.vertices.push( vertices[2] );
        aPlane.vertices.push( vertices[3] );
        aPlane.vertices.push( vertices[6] );
        aPlane.vertices.push( vertices[7] );
        aPlane.colors.push( cPlaneColor );
        aPlane.colors.push( cPlaneColor );
        aPlane.colors.push( cPlaneColor );
        aPlane.colors.push( cPlaneColor );
        aPlane.faces.push( new THREE.Face3( 0, 1, 2 ) );
        aPlane.faces.push( new THREE.Face3( 0, 2, 3) );
        aPlane.computeBoundingSphere();
    

    
    var cMaterial = new THREE.MeshBasicMaterial( {
		color: cPlaneColor,
		shading: THREE.FlatShading,
		polygonOffset: true,
		polygonOffsetFactor: 1,
		polygonOffsetUnits: 1,
        opacity: 0.5
	} );

    var aMaterial = new THREE.MeshBasicMaterial( {
		color: cPlaneColor,
		shading: THREE.FlatShading,
		polygonOffset: true,
		polygonOffsetFactor: 1,
		polygonOffsetUnits: 1,
        opacity: 0.5
	} );
	
    active_planes = [false, false, false, false];
    
    
    
	var material = new THREE.MeshPhongMaterial( {
		color: 0x000000,
		ambient: 0x404040,
		specular: 0x111111,
		shading: THREE.FlatShading,
		polygonOffset: true,
		polygonOffsetFactor: 1,
		polygonOffsetUnits: 1,
        transparent: true,
        opacity: 0.5
	} );
	
    
	for ( var i = 0, il = geometries.length; i < il; i ++ ) {

		// mesh
		mesh = new THREE.Mesh( geometries[ i ], material );
		scene.add( mesh );

		// helper
	 	egh = new THREE.EdgesHelper( mesh, 0xFFFFFF );
	 	egh.material.transparent = true;
	 	egh.material.linewidth = 2;
		scene.add( egh );

	}

    var cPlaneMesh = new THREE.Mesh(cPlane, cMaterial );
    scene.add( cPlaneMesh );

    var aPlaneMesh = new THREE.Mesh(aPlane, aMaterial );
    scene.add( aPlaneMesh );



}

function animate() {

	requestAnimationFrame( animate );  
	renderer.render( scene, camera );
    update();
}
        

function update()
{
    /*
	if ( keyboard.pressed("a") ) {
    
    }
	if ( keyboard.pressed("m") ) {
    
    }
	if ( keyboard.pressed("r") ) {
    
    }
	*/
    
	controls.update();
	//stats.update();
}
</script>
  </body>
</html>
